---
- name: Deploy backend stack
  hosts: backend
  become: true
  gather_facts: yes

  vars:
    app_user: "{{ ansible_user | default('team_user') }}"
    app_group: "{{ ansible_user | default('team_user') }}"
    registry: "{{ registry | default(ci_registry, true) }}"
    tag: "{{ tag | default(image_tag, true) }}"
    # Порты, которые публикуем наружу (нужны для preflight-проверки)
    published_ports:
      - 8080   # api-gateway
      - 8081   # qr-module
      - 8082   # storage-app
      - 8083   # auth-service
      - 9000   # MinIO S3
      - 9090   # MinIO console
    # Автоматически освобождать порты, если заняты контейнерами
    force_free_ports: true
    compose_abs_path: "{{ compose_dir }}/{{ compose_file }}"

  pre_tasks:
    - name: Ensure base packages present
      ansible.builtin.apt:
        name:
          - ca-certificates
          - curl
          - python3
          - python3-pip
        state: present
        update_cache: yes

    - name: Ensure required secrets exist
      ansible.builtin.assert:
        that:
          - auth_postgres_password | length > 8
          - storage_postgres_password | length > 8
          - jwt_secret | length >= 16
          - minio_secret_key | length >= 12
        fail_msg: "Missing/weak secrets in GitLab CI Variables."

    - name: Ensure deploy directory exists with owner
      ansible.builtin.file:
        path: "{{ compose_dir }}"
        state: directory
        owner: "{{ app_user }}"
        group: "{{ app_group }}"
        mode: "0755"

  roles:
    - role: nginx

  tasks:
    - name: Render deploy docker-compose from template
      ansible.builtin.template:
        src: "{{ playbook_dir }}/templates/docker-compose.deploy.yml.j2"
        dest: "{{ compose_abs_path }}"
        owner: "{{ app_user }}"
        group: "{{ app_group }}"
        mode: "0644"
      vars:
        registry: "{{ registry }}"
        tag: "{{ tag }}"

    - name: Render auth-service .env
      ansible.builtin.template:
        src: "{{ playbook_dir }}/templates/auth-service.env.j2"
        dest: "{{ compose_dir }}/auth-service.env"
        owner: "{{ app_user }}"
        group: "{{ app_group }}"
        mode: "0600"

    - name: Render storage-module .env
      ansible.builtin.template:
        src: "{{ playbook_dir }}/templates/storage-module.env.j2"
        dest: "{{ compose_dir }}/storage-module.env"
        owner: "{{ app_user }}"
        group: "{{ app_group }}"
        mode: "0600"

    - name: Docker login (registry)
      community.docker.docker_login:
        registry_url: "{{ ci_registry }}"
        username: "{{ ci_registry_user }}"
        password: "{{ ci_registry_password }}"
      when: ci_registry != ""

    # 1) Мягко гасим текущий проект (не трогаем volumes/образы)
    - name: Compose down (no volumes) to avoid stale resources
      community.docker.docker_compose:
        project_name: "{{ project_name }}"
        project_src: "{{ compose_dir }}"
        files: ["{{ compose_file }}"]
        state: absent
        remove_orphans: true
      ignore_errors: true

    # 2) Preflight — проверяем, не заняты ли наши порты другими контейнерами
    - name: Find containers publishing our target ports
      ansible.builtin.shell: |
        set -euo pipefail
        docker ps --format '{{"{{"}}.ID{{"}}"}} {{ "{{" }}.Names{{ "}}" }} {{ "{{" }}.Ports{{ "}}" }}' \
        | awk '/0\.0\.0\.0/ {print}'
      args:
        executable: /bin/bash
      register: docker_ps_ports
      changed_when: false

    - name: Build list of conflicting containers
      ansible.builtin.set_fact:
        conflicting_containers: >-
          {{
            docker_ps_ports.stdout_lines
            | map('regex_search', '^(\\S+)\\s+(\\S+)\\s+(.+)$')
            | list
            | map('last')
            | select('defined')
            | selectattr('2','search', '(' ~ (published_ports | join("|")) ~ ')')
            | list
          }}

    - name: Stop conflicting containers (auto-fix)
      when: force_free_ports and (conflicting_containers | length > 0)
      vars:
        ids: "{{ conflicting_containers | map('first') | list }}"
      community.docker.docker_container:
        name: "{{ item }}"
        state: stopped
      loop: "{{ ids }}"
      # Пытаемся по ID; если по имени нужно — можно дописать аналогичный цикл по именам
      ignore_errors: true

    # 3) Pull образов (явной командой — точно не запускает контейнеры)
    - name: Compose pull images only
      ansible.builtin.command:
        cmd: docker compose -f "{{ compose_abs_path }}" pull
      args:
        chdir: "{{ compose_dir }}"
      register: pull_out
      changed_when: "'Downloaded' in pull_out.stdout or 'Pulled' in pull_out.stdout"

    # 4) Поднимаем стек
    - name: Up stack (fresh)
      community.docker.docker_compose:
        project_name: "{{ project_name }}"
        project_src: "{{ compose_dir }}"
        files: ["{{ compose_file }}"]
        state: present

    # 5) (Диагностика на случай сбоев — можно закомментировать позже)
    - name: docker compose ps
      ansible.builtin.command:
        cmd: docker compose -f "{{ compose_abs_path }}" ps
      args:
        chdir: "{{ compose_dir }}"
      register: ps_out
      changed_when: false

    - name: Show compose ps
      ansible.builtin.debug:
        var: ps_out.stdout
